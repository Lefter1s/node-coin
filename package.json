{
  "name": "node-coin",
  "version": "0.3.9",
  "description": "coin client",
  "keywords": [
    "cannacoin"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/lefter1s/node-coin.git"
  },
  "author": {
    "name": "Lefter1s"
  },
  "main": "lib/coin.js",
  "engines": {
    "node": ">= 0.4.0"
  },
  "devDependencies": {
    "nodeunit": "*"
  },
  "readme": "# A Node.js coin Client!\n\n![coin](https://github.com/lefter1s)\n\nnode-coin is a coin client for Node.js. It is a fork of the excellent Kapitalize Bitcoin Client (now removed from GitHub) intended for use with coin. The purpose of this repository is:\n\n* Provide a one-stop resource for the Node.js developer to get started with coin integration.\n* Prevent would-be coin web developers worrying whether a Bitcoin client will work out of the box.\n* Promote Node.js development of coin web apps.\n* Identify and address any incompatibilities with the coin and Bitcoin APIs that exist now and/or in the future.\n\n## Dependencies\n\nYou'll need a running instance of [coind](https://github.com/Lefter1s/coin) to connect with. \n\nThen, install the node-coin NPM package.\n\n`npm install git://github.com/Lefter1s/node-coin/`\n\n## Examples\n\nSome code examples follow below, but for more complete examples, see [these snippets](https://github.com/coin-project/coin-code-snippets), or this [wallet app](comingsoon...) which was created to to test this module.\n\n```js\nvar coin = require('node-coin')()\n\ncoin.auth('myusername', 'mypassword')\n\ncoin.getDifficulty(function() {\n    console.log(arguments);\n})\n\n```\n\n## Chaining\n\nPretty much everything is chainable.\n\n```js\nvar coin = require('node-coin')()\n\ncoin\n.auth('MyUserName', 'mypassword')\n.getNewAddress()\n.getBalance()\n```\n\n## Methods\n\nThe [Litecoin API](https://litecoin.info/Litecoin_API) is supported as direct methods. Use either camelcase or lowercase.\n\n```js\ncoin.getNewAddress(function(err, address) {\n    this.validateaddress(address, function(err, info) {\n\n    })\n})\n```\n### .exec(command [string], ...arguments..., callback [function])\n\nExecutes the given command with optional arguments. Function `callback` defaults to `console.log`.\nAll of the API commands are supported in lowercase or camelcase. Or uppercase. Anycase!\n\n```js\ncoin.exec('getNewAddress')\n\ncoin.exec('getbalance', function(err, balance) {\n\n})\n```\n\n### .set(key [string, object], value [optional])\n\nAccepts either key & value strings or an Object containing settings, returns `this` for chainability.\n\n```js\ncoin.set('host', '127.0.0.1')\n```\n\n### .get(key [string])\n\nReturns the specified option's value\n\n```js\ncoin.get('user')\n```\n\n### .auth(user [string], pass [string])\n\nGenerates authorization header, returns `this` for chainability\n\n## Commands\n\nTODO: Write tests for these.\n\nAll [Litecoin API](https://litecoin.info/Litecoin_API) commands are supported, in lowercase or camelcase form.\n\n<table>\n<tr>\n<th> Command </th>\n<th> Parameters </th>\n<th> Description </th>\n<th> Requires unlocked wallet?\n</th></tr>\n<tr>\n<td> addmultisigaddress </td>\n<td> [nrequired] [\"key\",\"key\"] [account] </td>\n<td> <b>Currently only available on testnet</b> Add a nrequired-to-sign multisignature address to the wallet. Each key is a coin address or hex-encoded public key. If [account] is specified, assign address to [account]. </td>\n<td> N\n</td></tr>\n<tr>\n<td> backupwallet </td>\n<td> [destination] </td>\n<td> Safely copies wallet.dat to destination, which can be a directory or a path with filename. </td>\n<td> N\n</td></tr>\n<tr>\n<td> dumpprivkey </td>\n<td> [coinaddress] </td>\n<td> Reveals the private key corresponding to <coinaddress< </td>\n<td> Y\n</td></tr>\n<tr>\n<td> encryptwallet </td>\n<td> [passphrase] </td>\n<td> Encrypts the wallet with <passphrase<. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getaccount </td>\n<td> [coinaddress] </td>\n<td> Returns the account associated with the given address. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getaccountaddress </td>\n<td> [account] </td>\n<td> Returns the current coin address for receiving payments to this account. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getaddressesbyaccount </td>\n<td> [account] </td>\n<td> Returns the list of addresses for the given account. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getbalance </td>\n<td> [account] [minconf=1] </td>\n<td> If [account] is not specified, returns the server's total available balance.<br />If [account] is specified, returns the balance in the account. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getblock </td>\n<td> [hash] </td>\n<td> Returns information about the given block hash. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getblockcount </td>\n<td> </td>\n<td> Returns the number of blocks in the longest block chain. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getblockhash </td>\n<td> [index] </td>\n<td> Returns hash of block in best-block-chain at <index< </td>\n<td> N\n</td></tr>\n<tr>\n<td> getblocknumber </td>\n<td> </td>\n<td> <b>Deprecated</b>. Use getblockcount. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getconnectioncount </td>\n<td> </td>\n<td> Returns the number of connections to other nodes. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getdifficulty </td>\n<td> </td>\n<td> Returns the proof-of-work difficulty as a multiple of the minimum difficulty. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getgenerate </td>\n<td> </td>\n<td> Returns true or false whether coind is currently generating hashes </td>\n<td> N\n</td></tr>\n<tr>\n<td> gethashespersec </td>\n<td> </td>\n<td> Returns a recent hashes per second performance measurement while generating. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getinfo </td>\n<td> </td>\n<td> Returns an object containing various state info. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getmemorypool </td>\n<td> [data] </td>\n<td> If [data] is not specified, returns data needed to construct a block to work on:\n<ul><li> \"version\": block version\n</li><li> \"previousblockhash\": hash of current highest block\n</li><li> \"transactions\": contents of non-coinbase transactions that should be included in the next block\n</li><li> \"coinbasevalue\": maximum allowable input to coinbase transaction, including the generation award and transaction fees\n</li><li> \"time\": timestamp appropriate for next block\n</li><li> \"bits\": compressed target of next block\n</li></ul>\n<p>If [data] is specified, tries to solve the block and returns true if it was successful.\n</p>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> getmininginfo </td>\n<td> </td>\n<td> Returns an object containing mining-related information:\n<ul><li> blocks\n</li><li> currentblocksize\n</li><li> currentblocktx\n</li><li> difficulty\n</li><li> errors\n</li><li> generate\n</li><li> genproclimit\n</li><li> hashespersec\n</li><li> pooledtx\n</li><li> testnet\n</li></ul>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> getnewaddress </td>\n<td> [account] </td>\n<td> Returns a new coin address for receiving payments.  If [account] is specified (recommended), it is added to the address book so payments received with the address will be credited to [account]. </td>\n<td> N\n</td></tr>\n<tr>\n<td> getreceivedbyaccount </td>\n<td> [account] [minconf=1] </td>\n<td> Returns the total amount received by addresses with [account] in transactions with at least [minconf] confirmations. If [account] not provided return will include all transactions to all accounts. (version 0.3.24-beta) </td>\n<td> N\n</td></tr>\n<tr>\n<td> getreceivedbyaddress </td>\n<td> [coinaddress] [minconf=1] </td>\n<td> Returns the total amount received by <coinaddress< in transactions with at least [minconf] confirmations. While some might consider this obvious, value reported by this only considers *receiving* transactions. It does not check payments that have been made *from* this address. In other words, this is not \"getaddressbalance\". Works only for addresses in the local wallet, external addresses will always show 0. </td>\n<td> N\n</td></tr>\n<tr>\n<td> gettransaction </td>\n<td> [txid] </td>\n<td> Returns an object about the given transaction containing:\n<ul><li> \"amount\": total amount of the transaction\n</li><li> \"confirmations\":  number of confirmations of the transaction\n</li><li> \"txid\": the transaction ID\n</li><li> \"time\": time the transaction occurred\n</li><li> \"details\" - An array of objects containing:\n<ul><li> \"account\"\n</li><li> \"address\"\n</li><li> \"category\"\n</li><li> \"amount\"\n</li></ul>\n</li></ul>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> getwork </td>\n<td> [data] </td>\n<td> If [data] is not specified, returns formatted hash data to work on:\n<ul><li> \"midstate\": precomputed hash state after hashing the first half of the data\n</li><li> \"data\": block data\n</li><li> \"hash1\": formatted hash buffer for second hash\n</li><li> \"target\": little endian hash target\n</li></ul>\n<p>If [data] is specified, tries to solve the block and returns true if it was successful. \n</p>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> help </td>\n<td> [command] </td>\n<td> List commands, or get help for a command. </td>\n<td> N\n</td></tr>\n<tr>\n<td> importprivkey </td>\n<td> [coinprivkey] [label] </td>\n<td> Adds a private key (as returned by dumpprivkey) to your wallet. </td>\n<td> Y\n</td></tr>\n<tr>\n<td> keypoolrefill </td>\n<td> </td>\n<td> Fills the keypool, requires wallet passphrase to be set. </td>\n<td> Y\n</td></tr>\n<tr>\n<td> listaccounts </td>\n<td> [minconf=1] </td>\n<td> Returns Object that has account names as keys, account balances as values. </td>\n<td> N\n</td></tr>\n<tr>\n<td> listreceivedbyaccount </td>\n<td> [minconf=1] [includeempty=false] </td>\n<td> Returns an array of objects containing:\n<ul><li> \"account\": the account of the receiving addresses\n</li><li> \"amount\": total amount received by addresses with this account\n</li><li> \"confirmations\": number of confirmations of the most recent transaction included\n</li></ul>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> listreceivedbyaddress </td>\n<td> [minconf=1] [includeempty=false] </td>\n<td> Returns an array of objects containing:\n<ul><li> \"address\": receiving address\n</li><li> \"account\": the account of the receiving address\n</li><li> \"amount\": total amount received by the address\n</li><li> \"confirmations\": number of confirmations of the most recent transaction included\n</li></ul>\n<p>To get a list of accounts on the system, execute coind listreceivedbyaddress 0 true\n</p>\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> listsinceblock</td>\n<td> [blockhash] [target-confirmations] </td>\n<td> Get all transactions in blocks since block [blockhash], or all transactions if omitted. </td>\n<td> N\n</td></tr>\n<tr>\n<td> listtransactions </td>\n<td> [account] [count=10] [from=0] </td>\n<td> Returns up to [count] most recent transactions skipping the first [from] transactions for account [account]. If [account] not provided will return recent transaction from all accounts.\n</td>\n<td> N\n</td></tr>\n<tr>\n<td> move </td>\n<td> [fromaccount] [toaccount] [amount] [minconf=1] [comment] </td>\n<td> Move from one account in your wallet to another </td>\n<td> N\n</td></tr>\n<tr>\n<td> sendfrom </td>\n<td> [fromaccount] [tocoinaddress] [amount] [minconf=1] [comment] [comment-to] </td>\n<td> <amount< is a real and is rounded to 8 decimal places. Will send the given amount to the given address, ensuring the account has a valid balance using [minconf] confirmations. Returns the transaction ID if successful (not in JSON object). </td>\n<td> Y\n</td></tr>\n<tr>\n<td> sendmany </td>\n<td> [fromaccount] [address:amount,...] [minconf=1] [comment] </td>\n<td> amounts are double-precision floating point numbers </td>\n<td> Y\n</td></tr>\n<tr>\n<td> sendtoaddress </td>\n<td> [coinaddress] [amount] [comment] [comment-to] </td>\n<td> <amount< is a real and is rounded to 8 decimal places. Returns the transaction ID <txid< if successful. </td>\n<td> Y\n</td></tr>\n<tr>\n<td> setaccount </td>\n<td> [coinaddress] [account] </td>\n<td> Sets the account associated with the given address. Assigning address that is already assigned to the same account will create a new address associated with that account. </td>\n<td> N\n</td></tr>\n<tr>\n<td> setgenerate </td>\n<td> [generate] [genproclimit] </td>\n<td> [generate] is true or false to turn generation on or off.\n\nGeneration is limited to [genproclimit] processors, -1 is unlimited. </td>\n<td> N\n</td></tr>\n<tr>\n<td> signmessage </td>\n<td> [coinaddress] [message] </td>\n<td> Sign a message with the private key of an address. </td>\n<td> Y\n</td></tr>\n<tr>\n<td> settxfee </td>\n<td> [amount] </td>\n<td> [amount] is a real and is rounded to the nearest 0.00000001 </td>\n<td> N\n</td></tr>\n<tr>\n<td> stop </td>\n<td> </td>\n<td> Stop coin server. </td>\n<td> N\n</td></tr>\n<tr>\n<td> validateaddress </td>\n<td> [coinaddress] </td>\n<td> Return information about [coinaddress]. </td>\n<td> N\n</td></tr>\n<tr>\n<td> verifymessage </td>\n<td> [coinaddress] [signature] [message] </td>\n<td> Verify a signed message. </td>\n<td> N\n</td></tr>\n<tr>\n<td> walletlock </td>\n<td>  </td>\n<td> Removes the wallet encryption key from memory, locking the wallet. After calling this method,  you will need to call walletpassphrase again before being able to call any methods which require the wallet to be unlocked. </td>\n<td> N\n</td></tr>\n<tr>\n<td> walletpassphrase </td>\n<td> [passphrase] [timeout] </td>\n<td> Stores the wallet decryption key in memory for <timeout< seconds. </td>\n<td> N\n</td></tr>\n<tr>\n<td> walletpassphrasechange </td>\n<td> [oldpassphrase] [newpassphrase] </td>\n<td> Changes the wallet passphrase from <oldpassphrase< to <newpassphrase<. </td>\n<td> N\n</td></tr></table>\n\n## Options\n\nYou may pass options to the initialization function or to the `set` method.\n\n```js\n\nvar coin = require('coin')({\n    user:'user'\n})\n\ncoin.set('pass', 'somn')\ncoin.set({port:7142})\n\n```\n\nAvailable options and default values:\n\n+ host *localhost*\n+ port *1511*\n+ user\n+ pass\n+ passphrasecallback\n+ https\n+ ca\n\n### Passphrase Callback\n\nWith an encryped wallet, any operation that accesses private keys requires a wallet unlock. A wallet is unlocked using the `walletpassphrase <passphrase> <timeout>` JSON-RPC method: the wallet will relock after `timeout` seconds.\n\nYou may pass an optional function `passphrasecallback` to the `node-coin` initialization function to manage wallet unlocks. `passphrasecallback` should be a function accepting three arguments:\n\n    function(command, args, callback) {}\n\n+ **command** is the command that failed due to a locked wallet.\n+ **args** is the arguments for the failed command.\n+ **callback** is a typical node-style continuation callback of the form `function(err, passphrase, timeout) {}`. Call callback with the wallet passphrase and desired timeout from within your passphrasecallback to unlock the wallet.\n\nYou may hard code your passphrase (not recommended) as follows:\n\n```js\nvar coin = require('node-coin')({\n    passphrasecallback: function(command, args, callback) {\n        callback(null, 'passphrase', 30);\n    }\n})\n```\n\nBecause `passphrasecallback` is a continuation, you can retrieve the passphrase in an asynchronous manner. For example, by prompting the user:\n\n```js\nvar readline = require('readline')\n\nvar rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\n\nvar coin = require('node-coin')({\n  passphrasecallback: function(command, args, callback) {\n    rl.question('Enter passphrase for \"' + command + '\" operation: ', function(passphrase) {\n      if (passphrase) {\n        callback(null, passphrase, 1)\n      } else {\n        callback(new Error('no passphrase entered'))\n      }\n    })\n  }\n})\n```\n\n### Secure RPC with SSL\n\nBy default `coind` exposes its JSON-RPC interface via HTTP; that is, all RPC commands are transmitted in plain text across the network! To secure the JSON-RPC channel you can supply `coind` with a self-signed SSL certificate and an associated private key to enable HTTPS. For example, in your `coin.conf`:\n\n    rpcssl=1\n    rpcsslcertificatechainfile=/etc/ssl/certs/coind.crt\n    rpcsslprivatekeyfile=/etc/ssl/private/coind.pem\n\nIn order to securely access an SSL encrypted JSON-RPC interface you need a copy of the self-signed certificate from the server: in this case `coind.crt`. Pass your self-signed certificate in the `ca` option and set `https: true` and node-coin is secured!\n    \n```js\nvar fs = require('fs')\n\nvar ca = fs.readFileSync('coind.crt')\n\nvar coin = require('node-coin')({\n  user: 'rpcusername',\n  pass: 'rpcpassword',\n  https: true,\n  ca: ca\n})\n```\n\n## Testing\n\n```\nnpm install -g nodeunit\n\nnodeunit test/test-node-coin.js\n```\n\n## Bounties\n\n[coin](http://www.coin.com) donation address is CdmcSJ8aokHkkZS1W6KCvXiJEGw4sGkRVj\n\nDonations in [coin](http://www.coin.cc) will be used for bounties. The first bounty will be awarded for creating a unit test suite. As a side note: I encourage all GitHub repository owners to post a donation address so their community can easily support development financially. \n\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/lefter1s/node-coin/issues"
  },
  "homepage": "https://github.com/lefter1s/node-coin",
  "_id": "node-coin@0.3.9",
  "_shasum": "f9e29c0407d1a33d88752de3a2c9bb684766b4a2",
  "_resolved": "git://github.com/Lefter1s/node-coin/#ccc09f560a72194713d7d991f23703e84b0444e1",
  "_from": "git://github.com/Lefter1s/node-coin/"
}
